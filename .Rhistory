kable_styling(bootstrap_options = c("striped", "hover"))
#| fig-dpi: 300
#| fig-height: 6
#| fig-width: 12
# Median claim amount trend showing financial severity.
claims_plot <- ggplot(df_claims, aes(x = date, y = median_claim)) +
geom_line(color = "#27AE60", linewidth = 1.2) +
geom_point(color = "#27AE60", size = 2.5) +
geom_hline(aes(yintercept = median_claim_baseline),
linetype = "dashed", color = "#E74C3C", linewidth = 1) +
annotate("text", x = min(df_claims$date), y = df_claims$median_claim_baseline[1] * 1.05,
label = sprintf("Pre-Pandemic Baseline: $%s",
comma(df_claims$median_claim_baseline[1])),
hjust = 0, color = "#E74C3C", fontface = "bold") +
geom_vline(xintercept = as.Date("2020-03-01"),
linetype = "dotted", color = "gray50", alpha = 0.7) +
geom_vline(xintercept = as.Date("2021-09-30"),
linetype = "dotted", color = "gray50", alpha = 0.7) +
scale_y_continuous(labels = dollar) +
labs(
title = "Median Eviction Claim Amount Over Time",
subtitle = "Claims increased during moratorium as arrears accumulated then stabilized",
x = "Date (Month)",
y = "Median Claim Amount (USD)",
caption = "Data: Philadelphia Eviction Claims | Dashed line = pre-pandemic baseline"
) +
theme_minimal(base_size = 12) +
theme(plot.title = element_text(face = "bold", size = 14))
claims_plot
# Calculate claim statistics by period.
df_claims %>%
mutate(Period = case_when(
date < as.Date("2020-03-01") ~ "Pre-Moratorium",
date >= as.Date("2020-03-01") & date <= as.Date("2021-09-30") ~ "Moratorium",
date > as.Date("2021-09-30") ~ "Post-Moratorium"
)) %>%
group_by(Period) %>%
summarize(
Mean_Claim = mean(median_claim, na.rm = TRUE),
Median_Claim = median(median_claim, na.rm = TRUE),
Ratio_to_Baseline = mean(claim_ratio, na.rm = TRUE),
.groups = "drop"
) %>%
kable(digits = 2) %>%
kable_styling(bootstrap_options = c("striped", "hover"))
#| fig-dpi: 300
#| fig-height: 7
#| fig-width: 12
# Calculate total and mean filings by racial majority category.
racial_summary <- df_monthly %>%
filter(!is.na(racial_majority), racial_majority != "") %>%
group_by(racial_majority) %>%
summarize(
Total_Filings = sum(filings_count, na.rm = TRUE),
Mean_Filings = mean(filings_count, na.rm = TRUE),
Median_Filings = median(filings_count, na.rm = TRUE),
N_Tract_Months = n(),
N_Unique_Tracts = n_distinct(GEOID),
.groups = "drop"
) %>%
arrange(desc(Total_Filings))
# Create bar chart showing total filings by racial majority.
racial_plot <- ggplot(racial_summary, aes(x = reorder(racial_majority, Total_Filings),
y = Total_Filings)) +
geom_col(aes(fill = Total_Filings), width = 0.7) +
coord_flip() +
scale_fill_gradient(low = "#BDC3C7", high = "#E74C3C", labels = comma) +
scale_y_continuous(labels = comma) +
labs(
title = "Total Eviction Filings by Census Tract Racial Majority",
subtitle = "Stark disparities indicate structural inequities requiring policy attention",
x = "Census Tract Racial Majority",
y = "Total Eviction Filings (2020-2025)",
fill = "Total\nFilings",
caption = "Data: Philadelphia Monthly Eviction Filings"
) +
theme_minimal(base_size = 12) +
theme(
plot.title = element_text(face = "bold", size = 14),
legend.position = "right"
)
racial_plot
# Print detailed racial disparity statistics.
racial_summary %>%
kable(digits = 1) %>%
kable_styling(bootstrap_options = c("striped", "hover"))
#| fig-dpi: 300
#| fig-height: 7
#| fig-width: 14
# Calculate monthly totals by racial majority for trend analysis.
racial_temporal <- df_monthly %>%
filter(!is.na(racial_majority), racial_majority != "") %>%
group_by(date, racial_majority) %>%
summarize(Total_Filings = sum(filings_count, na.rm = TRUE), .groups = "drop")
# Create line plot showing differential temporal patterns.
racial_temporal_plot <- ggplot(racial_temporal,
aes(x = date, y = Total_Filings, color = racial_majority)) +
geom_line(linewidth = 1.1, alpha = 0.8) +
geom_vline(xintercept = as.Date("2020-03-01"),
linetype = "dashed", color = "gray50", alpha = 0.5) +
geom_vline(xintercept = as.Date("2021-09-30"),
linetype = "dashed", color = "gray50", alpha = 0.5) +
scale_y_continuous(labels = comma) +
scale_color_viridis_d(option = "plasma", end = 0.9) +
labs(
title = "Monthly Eviction Filings by Racial Majority: Temporal Trends",
subtitle = "Differential recovery patterns suggest unequal policy impact across communities",
x = "Date (Month)",
y = "Total Monthly Filings",
color = "Racial Majority",
caption = "Data: Philadelphia Monthly Eviction Filings | Vertical lines = policy changes"
) +
theme_minimal(base_size = 12) +
theme(
plot.title = element_text(face = "bold", size = 14),
legend.position = "bottom"
)
racial_temporal_plot
#| fig-dpi: 300
#| fig-height: 6
#| fig-width: 14
# Calculate weekly totals by racial majority.
weekly_racial <- df_weekly %>%
filter(!is.na(racial_majority), racial_majority != "") %>%
group_by(date, racial_majority) %>%
summarize(Total_Filings = sum(filings_count, na.rm = TRUE), .groups = "drop")
# Create stacked area chart showing composition over time.
weekly_racial_plot <- ggplot(weekly_racial,
aes(x = date, y = Total_Filings, fill = racial_majority)) +
geom_area(alpha = 0.8, color = "white", linewidth = 0.3) +
scale_y_continuous(labels = comma) +
scale_fill_viridis_d(option = "turbo", end = 0.9) +
labs(
title = "Weekly Eviction Filings by Racial Majority: Stacked Composition",
subtitle = "Proportional burden shifts over time revealing differential vulnerability",
x = "Date (Week Ending)",
y = "Total Weekly Filings",
fill = "Racial Majority",
caption = "Data: Philadelphia Weekly Eviction Filings"
) +
theme_minimal(base_size = 12) +
theme(
plot.title = element_text(face = "bold", size = 14),
legend.position = "bottom"
)
weekly_racial_plot
# Calculate total filings per tract across entire period.
tract_totals <- df_monthly %>%
group_by(GEOID, racial_majority) %>%
summarize(
Total_Filings = sum(filings_count, na.rm = TRUE),
Mean_Monthly = mean(filings_count, na.rm = TRUE),
Median_Monthly = median(filings_count, na.rm = TRUE),
SD_Monthly = sd(filings_count, na.rm = TRUE),
CV = SD_Monthly / Mean_Monthly,
Months_Observed = n(),
Months_With_Filings = sum(filings_count > 0),
.groups = "drop"
)
# Identify top 20 highest-risk tracts.
top_risk_tracts <- tract_totals %>%
arrange(desc(Total_Filings)) %>%
head(20)
# Top 20 highest-risk census tracts (Total Filings 2020-2025).
top_risk_tracts %>%
select(GEOID, racial_majority, Total_Filings, Mean_Monthly, CV) %>%
kable(digits = 2) %>%
kable_styling(bootstrap_options = c("striped", "hover"))
# Calculate concentration statistics.
total_system_filings <- sum(tract_totals$Total_Filings)
top_20_pct <- sum(top_risk_tracts$Total_Filings) / total_system_filings * 100
cat(sprintf("Concentration: Top 20 tracts account for %.1f%% of all filings\n", top_20_pct))
#| fig-dpi: 300
#| fig-height: 10
#| fig-width: 10
# Create scatter plot showing mean versus volatility.
volatility_plot <- tract_totals %>%
filter(Mean_Monthly > 0.1) %>%
ggplot(aes(x = Mean_Monthly, y = CV)) +
geom_hex(bins = 40) +
scale_fill_viridis_c(option = "magma", trans = "log10", labels = comma) +
scale_x_log10(labels = comma) +
scale_y_log10() +
geom_hline(yintercept = 1, linetype = "dashed", color = "white", linewidth = 1) +
labs(
title = "Tract Volatility: Coefficient of Variation vs Mean Filings",
subtitle = "High CV indicates unpredictable filing patterns requiring early warning systems.",
x = "Mean Monthly Filings per Tract [Log Scale]",
y = "Coefficient of Variation (SD / Mean) [Log Scale]",
fill = "Tract\nCount",
caption = "Data: Philadelphia Monthly Eviction Filings | CV = 1 Ref Line"
) +
theme_minimal(base_size = 12) +
theme(plot.title = element_text(face = "bold", size = 14))
volatility_plot
#| fig-dpi: 300
#| fig-height: 6
#| fig-width: 14
# Calculate system-wide ratio to pre-pandemic baseline.
weekly_baseline_ratio <- df_weekly %>%
group_by(date) %>%
summarize(
Total_Filings = sum(filings_count, na.rm = TRUE),
Total_Baseline = sum(filings_avg_prepandemic_baseline, na.rm = TRUE),
.groups = "drop"
) %>%
filter(Total_Baseline > 0) %>%
mutate(Ratio_to_Baseline = Total_Filings / Total_Baseline)
# Create line plot showing normalized recovery.
baseline_ratio_plot <- ggplot(weekly_baseline_ratio, aes(x = date, y = Ratio_to_Baseline)) +
geom_line(color = "#16A085", linewidth = 0.8, alpha = 0.6) +
geom_smooth(method = "loess", se = TRUE, color = "#E74C3C", linewidth = 1.2, span = 0.15) +
geom_hline(yintercept = 1, linetype = "dashed", color = "black", linewidth = 1) +
annotate("text", x = min(weekly_baseline_ratio$date), y = 1.05,
label = "Pre-Pandemic Average", hjust = 0, fontface = "bold") +
geom_vline(xintercept = as.Date("2020-03-01"),
linetype = "dotted", color = "gray50", alpha = 0.7) +
geom_vline(xintercept = as.Date("2021-09-30"),
linetype = "dotted", color = "gray50", alpha = 0.7) +
labs(
title = "Weekly Filings Normalized to Pre-Pandemic Baseline",
subtitle = "Ratio > 1 indicates system stress relative to historical norm | Smoothed trend in red",
x = "Date (Week Ending)",
y = "Weekly Filings / Pre-Pandemic Average Ratio",
caption = "Data: Philadelphia Weekly Eviction Filings"
) +
theme_minimal(base_size = 12) +
theme(plot.title = element_text(face = "bold", size = 14))
baseline_ratio_plot
# Calculate summary statistics by period.
weekly_baseline_ratio %>%
mutate(Period = case_when(
date < as.Date("2020-03-01") ~ "Pre-Moratorium",
date >= as.Date("2020-03-01") & date <= as.Date("2021-09-30") ~ "Moratorium",
date > as.Date("2021-09-30") ~ "Post-Moratorium"
)) %>%
group_by(Period) %>%
summarize(
Mean_Ratio = mean(Ratio_to_Baseline, na.rm = TRUE),
Median_Ratio = median(Ratio_to_Baseline, na.rm = TRUE),
.groups = "drop"
) %>%
kable(digits = 2) %>%
kable_styling(bootstrap_options = c("striped", "hover"))
# Calculate total filings per tract across the entire study period.
df_monthly_agg <- df_monthly %>%
rename(filings_count = df_eviction) %>%
group_by(GEOID) %>%
summarise(
Total_Filings = sum(filings_count, na.rm = TRUE),
.groups = "drop"
) %>%
# Convert GEOID to character to ensure successful join with geometry.
mutate(GEOID = as.character(GEOID))
# Calculate the average weekly filings per tract across the study period.
df_weekly_agg <- df_weekly_full %>%
rename(filings_count = filings_2020) %>%
group_by(GEOID) %>%
summarise(
Avg_Weekly_Filings = mean(filings_count, na.rm = TRUE),
.groups = "drop"
) %>%
# Convert GEOID to character to ensure successful join with geometry.
mutate(GEOID = as.character(GEOID))
#| fig-width: 12
#| fig-height: 8
#| fig-dpi: 300
# Define a common color scale for visual consistency.
common_fill_scale <- scale_fill_viridis_c(
trans = "log10",
labels = comma,
na.value = "gray70",
direction = -1,
name = "Count (Log)"  # Add explicit shared legend name
)
# Total Long-Term Filings (Overall Risk)
map_total_risk <- ggplot(tract_map_monthly) +
geom_sf(aes(fill = Total_Filings + 1), color = "white", linewidth = 0.1) +
common_fill_scale +
labs(
title = "Total Eviction Filings (2020-2023)",
subtitle = "Long-term risk and structural disparity."
) +
coord_sf(datum = NA) +
theme_void()
# Calculate total filings per tract across the entire study period.
df_monthly_agg <- df_monthly %>%
group_by(GEOID) %>%
summarise(
Total_Filings = sum(filings_count, na.rm = TRUE),
.groups = "drop"
) %>%
mutate(GEOID = as.character(GEOID))
# Perform spatial join for long-term risk.
tract_map_monthly <- tract_geo %>%
left_join(df_monthly_agg, by = "GEOID")
# Tracts data.
tract_geo <- st_read("data/pa_tracts/pa_tracts.shp") %>%
filter(COUNTYFP = "101")
# Tracts data.
tract_geo <- st_read("data/pa_tracts/pa_tracts.shp") %>%
filter(COUNTYFP == "101")
# Calculate total filings per tract across the entire study period.
df_monthly_agg <- df_monthly %>%
group_by(GEOID) %>%
summarise(
Total_Filings = sum(filings_count, na.rm = TRUE),
.groups = "drop"
) %>%
mutate(GEOID = as.character(GEOID))
# Perform spatial join for long-term risk.
tract_map_monthly <- tract_geo %>%
left_join(df_monthly_agg, by = "GEOID")
# Calculate the average weekly filings per tract across the study period.
df_weekly_agg <- df_weekly_full %>%
rename(filings_count = filings_2020) %>%
group_by(GEOID) %>%
summarise(
Avg_Weekly_Filings = mean(filings_count, na.rm = TRUE),
.groups = "drop"
) %>%
# Convert GEOID to character to ensure successful join with geometry.
mutate(GEOID = as.character(GEOID))
# Calculate the average weekly filings per tract across the study period.
df_weekly_agg <- df_weekly %>%
group_by(GEOID) %>%
summarise(
Avg_Weekly_Filings = mean(filings_count, na.rm = TRUE),
.groups = "drop"
) %>%
mutate(GEOID = as.character(GEOID))
# Average weekly filings per tract calculated for short-term risk map.
tract_map_weekly <- tract_geo %>%
left_join(df_weekly_agg, by = "GEOID")
#| fig-width: 12
#| fig-height: 8
#| fig-dpi: 300
# Define a common color scale for visual consistency.
common_fill_scale <- scale_fill_viridis_c(
trans = "log10",
labels = comma,
na.value = "gray70",
direction = -1,
name = "Count (Log)"  # Add explicit shared legend name
)
# Total Long-Term Filings (Overall Risk)
map_total_risk <- ggplot(tract_map_monthly) +
geom_sf(aes(fill = Total_Filings + 1), color = "white", linewidth = 0.1) +
common_fill_scale +
labs(
title = "Total Eviction Filings (2020-2023)",
subtitle = "Long-term risk and structural disparity."
) +
coord_sf(datum = NA) +
theme_void()
# Average Weekly Filings (Volatility/Short-Term Risk)
map_weekly_avg <- ggplot(tract_map_weekly) +
geom_sf(aes(fill = Avg_Weekly_Filings + 1), color = "white", linewidth = 0.1) +
common_fill_scale +
labs(
title = "Average Weekly Filings",
subtitle = "Normalized view of short-term filing activity."
) +
coord_sf(datum = NA) +
theme_void()
# Map showing average monthly and weekly eviction filings.
(map_total_risk | map_weekly_avg) +
plot_layout(guides = "collect") &
theme(legend.position = "bottom", legend.direction = "horizontal")
library(dplyr)
library(stringr)
library(tidyverse)
library(tidyr)
library(lubridate)
library(sf)
# Load longitudinal certification data for time-based analysis.
certs_data <- read.csv("data/license_inspection/BUILDING_CERTS.csv")
# Convert inspection date column to date object.
certs_data$inspectiondate <- ymd_hms(certs_data$inspectiondate)
# Convert expiration date column to date object.
certs_data$expirationdate <- ymd_hms(certs_data$expirationdate)
# Create year variable for historical distribution analysis.
certs_data$inspection_year <- year(certs_data$inspectiondate)
cat("\nBUILDING_CERTS Dimension:", dim(certs_data))
cat("\n\nBUILDING_CERTS Columns:\n\n")
print(lapply(certs_data, class))
certs_data
# Calculate frequency of different certification types.
cert_type_counts <- certs_data %>%
group_by(buildingcerttype) %>%
summarise(count = n()) %>%
arrange(desc(count))
# Top 10 certification types.
cert_type_plot <- ggplot(cert_type_counts[1:10,], aes(x = reorder(buildingcerttype, count), y = count)) +
geom_bar(stat = "identity", fill = "skyblue") +
coord_flip() +
labs(
title = "Top Ten Building Certification Types",
x = "Certification Type",
y = "Count of Certifications"
) +
theme_minimal()
# Distribution of different certification types.
cert_type_plot
# Clean result column by grouping similar failure statuses.
certs_data$result_clean <- recode(certs_data$inspectionresult,
"Certified" = "Safe",
"Unsafe" = "Failure",
"Deficient" = "Failure",
"Safe with Repair" = "Safe"
)
# Frequency of inspection results.
result_counts <- certs_data %>%
group_by(result_clean) %>%
summarise(count = n())
# Distribution of final inspection results.
result_plot <- ggplot(result_counts, aes(x = result_clean, y = count, fill = result_clean)) +
geom_bar(stat = "identity") +
labs(
title = "Distribution of Final Inspection Results",
x = "Inspection Result",
y = "Count"
) +
theme_minimal()
# Count of final inspection outcomes.
result_plot
# Historical trend of certifications over time.
year_plot <- ggplot(certs_data, aes(x = inspection_year)) +
geom_histogram(binwidth = 1, fill = "darkblue", color = "white") +
labs(
title = "Number of Certifications by Inspection Year",
x = "Inspection Year",
y = "Count of Certifications"
) +
theme_minimal()
# Histogram shows volume of inspections per year.
year_plot
# Calculate duration in days between inspection and expiration date.
certs_data$days_until_expiration <- as.numeric(difftime(certs_data$expirationdate, certs_data$inspectiondate, units = "days"))
# Visualize distribution of certification duration.
duration_plot <- ggplot(certs_data, aes( x = days_until_expiration)) +
geom_histogram(bins = 30, fill = "darkgreen", color = "white") +
labs(
title = "Distribution of Certification Duration in Days",
x = "Certification Duration (Days)",
y = "Count"
) +
theme_minimal()
# Length of certification period.
duration_plot
opa_parcels <- st_read("data/DOR_Parcel/DOR_Parcel.shp") %>%
drop_na(c(addr_sourc, addr_std)) %>%
select(c(addr_sourc, addr_std, parcel))
certs_data <- certs_data %>%
drop_na(address)
# # Check for exact matches and create a new logical column
# opa_parcels$match <- opa_parcels$addr_sourc == opa_parcels$addr_std
#
# print(sum(!opa_parcels$match))
#
# # Print the data frame with the new column
# print(df)
certs_data$addr_std <- certs_data$address
merged_by_addr_std <- inner_join(opa_parcels, certs_data, by = "addr_std", relationship = "many-to-many")
# Calculate Failure Rate by Council District.
district_risk <- merged_by_addr_std %>%
group_by(council_district) %>%
summarise(
total_certs = n(),
failure_count = sum(result_clean == "Failure"),
failure_rate = failure_count / total_certs
) %>%
arrange(desc(failure_rate))
# Failure rate calculated for each council district.
# Visualize Failure Rate by Council District (Spatial-Proxy).
district_risk_plot <- ggplot(district_risk, aes(x = reorder(council_district, failure_rate), y = failure_rate)) +
geom_bar(stat = "identity", fill = "firebrick") +
labs(
title = "Failure Rate by City Council District",
x = "Council District",
y = "Failure Rate (Proportion of Total Certs)"
) +
theme_minimal()
# Bar plot shows distribution of failure risk across political boundaries.
district_risk_plot
# Analyze contractor performance by filtering top contractors.
top_contractors <- merged_by_addr_std %>%
count(contractorname) %>%
arrange(desc(n)) %>%
head(10) %>%
pull(contractorname)
# Top 10 contractors identified by volume.
# Filter data for only top contractors and remove missing duration values.
contractor_data <- merged_by_addr_std %>%
filter(contractorname %in% top_contractors) %>%
filter(!is.na(days_until_expiration))
# Data subsetted to include only high-volume contractors.
# Visualize duration by contractor (potential bias check).
contractor_duration_plot <- ggplot(contractor_data, aes(x = reorder(contractorname,
days_until_expiration,
FUN = median),
y = days_until_expiration)) +
geom_boxplot(fill = "gold") +
coord_flip() +
labs(
title = "Certification Duration by Top 10 Contractors",
x = "Contractor Name",
y = "Certification Duration (Days)"
) +
theme_minimal()
# Box plot compares median certification duration across inspection companies.
contractor_duration_plot
