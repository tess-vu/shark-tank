title = "Total Eviction Filings by Census Tract (2020-2025)",
fill = "Total\nFilings",
caption = "Data: Philadelphia Eviction Filings via Eviction Lab"
) +
theme_void() +
theme(
plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
plot.subtitle = element_text(size = 11, hjust = 0.5),
legend.position = "right"
)
# Display eviction map.
eviction_map
#| fig-dpi: 300
#| fig-height: 10
#| fig-width: 10
# Join tax data to spatial geometry.
philly_tax_sf <- philly_tracts_sf %>%
left_join(df_tax, by = "GEOID")
# Create choropleth map of average tax balance.
tax_map <- ggplot(philly_tax_sf) +
geom_sf(aes(fill = avg_balance), color = NA) +
scale_fill_viridis_c(
option = "plasma",
trans = "log1p",
labels = dollar_format(),
na.value = "gray50"
) +
labs(
title = "Average Property Tax Delinquency by Census Tract",
fill = "Average\nTax\nBalance",
caption = "Data: OpenDataPhilly Real Estate Tax Balances"
) +
theme_void() +
theme(
plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
plot.subtitle = element_text(size = 11, hjust = 0.5),
legend.position = "right"
)
# Display tax map.
tax_map
#| fig-dpi: 300
#| fig-height: 6
#| fig-width: 14
#| message: FALSE
#| warning: FALSE
# Calculate system-wide ratio to pre-pandemic baseline over time.
weekly_baseline_ratio <- df_weekly %>%
group_by(date) %>%
summarize(
total_filings = sum(filings_count, na.rm = TRUE),
total_baseline = sum(filings_avg_prepandemic_baseline, na.rm = TRUE),
.groups = "drop"
) %>%
filter(total_baseline > 0) %>%
mutate(ratio_to_baseline = total_filings / total_baseline)
# Create line plot showing normalized recovery trajectory.
# Ratio greater than 1 indicates system stress relative to historical norm.
baseline_ratio_plot <- ggplot(weekly_baseline_ratio, aes(x = date, y = ratio_to_baseline)) +
geom_line(color = "#16A085", linewidth = 0.8, alpha = 0.6) +
geom_smooth(method = "loess", se = TRUE, color = "#E74C3C", linewidth = 1.2, span = 0.15) +
geom_hline(yintercept = 1, linetype = "dashed", color = "black", linewidth = 1) +
annotate("text", x = min(weekly_baseline_ratio$date), y = 1.05,
label = "Pre-Pandemic Average", hjust = 0, fontface = "bold") +
geom_vline(xintercept = as.Date("2020-03-01"),
linetype = "dotted", color = "gray50", alpha = 0.7) +
geom_vline(xintercept = as.Date("2021-09-30"),
linetype = "dotted", color = "gray50", alpha = 0.7) +
labs(
title = "Weekly Filings Normalized to Pre-Pandemic Baseline",
x = "Date (Week)",
y = "Weekly Filings / Pre-Pandemic Average Ratio",
caption = "Data: Philadelphia Weekly Eviction Filings via Eviction Lab"
) +
theme_minimal(base_size = 12) +
theme(plot.title = element_text(face = "bold", size = 14))
# Display baseline ratio plot.
baseline_ratio_plot
# Calculate summary statistics by policy period.
weekly_baseline_ratio %>%
mutate(period = case_when(
date < as.Date("2020-03-01") ~ "pre_moratorium",
date >= as.Date("2020-03-01") & date <= as.Date("2021-09-30") ~ "moratorium",
date > as.Date("2021-09-30") ~ "post_moratorium"
)) %>%
group_by(period) %>%
summarize(
n_weeks = n(),
mean_ratio = mean(ratio_to_baseline, na.rm = TRUE),
median_ratio = median(ratio_to_baseline, na.rm = TRUE),
.groups = "drop"
) %>%
kable(digits = 2, caption = "Baseline Ratio Statistics by Policy Period") %>%
kable_styling(bootstrap_options = c("striped", "hover"))
# Create lagged features.
df_model_prep <- df_monthly %>%
filter(GEOID != "sealed", !is.na(GEOID), GEOID != "") %>%
arrange(GEOID, date) %>%
group_by(GEOID) %>%
mutate(
# One month lag captures immediate momentum.
filings_lag1 = lag(filings_count, n = 1, order_by = date),
# Two month lag captures medium-term trend.
filings_lag2 = lag(filings_count, n = 2, order_by = date),
# Three month lag captures quarterly pattern.
filings_lag3 = lag(filings_count, n = 3, order_by = date),
# Rolling 3-month average smooths volatility.
filings_ma3 = rollmean(filings_count, k = 3, fill = NA, align = "right")
) %>%
ungroup()
# Check missingness of lag variables.
lag_coverage <- df_model_prep %>%
summarize(
total_obs = n(),
missing_lag1 = sum(is.na(filings_lag1)),
missing_lag2 = sum(is.na(filings_lag2)),
missing_lag3 = sum(is.na(filings_lag3)),
missing_ma3 = sum(is.na(filings_ma3)),
pct_missing_lag1 = missing_lag1 / total_obs * 100,
pct_missing_lag2 = missing_lag2 / total_obs * 100,
pct_missing_lag3 = missing_lag3 / total_obs * 100,
pct_missing_ma3 = missing_ma3 / total_obs * 100
)
# Display lag coverage stats.
lag_coverage %>%
kable(digits = 1, caption = "Lagged Variable Coverage Stats") %>%
kable_styling(bootstrap_options = c("striped", "hover"))
# There are around 37% zeros, so add zero flags for last month and consecutive.
df_model_prep <- df_model_prep %>%
group_by(GEOID) %>%
mutate(
was_zero_last_month = lag(ifelse(filings_count == 0, 1, 0)),
consecutive_zeros = sequence(rle(filings_count == 0)$lengths) * (filings_count == 0)
) %>%
ungroup()
# Check missingness of zero flag variables.
zero_coverage <- df_model_prep %>%
summarize(
total_obs = n(),
missing_zero_last_month = sum(is.na(was_zero_last_month)),
missing_consecutive_zeros = sum(is.na(consecutive_zeros)),
pct_missing_zero_last_month = missing_zero_last_month / total_obs * 100,
pct_missing_consecutive_zeros = missing_consecutive_zeros / total_obs * 100
)
# Display zero flag coverage stats.
zero_coverage %>%
kable(digits = 1, caption = "Zero Flag Variable Coverage Stats") %>%
kable_styling(bootstrap_options = c("striped", "hover"))
# Create year-month key for joining claims data to tract-level data.
df_model_prep <- df_model_prep %>%
mutate(year_month = floor_date(date, "month"))
df_claims_join <- df_claims %>%
mutate(year_month = floor_date(date, "month")) %>%
dplyr::select(year_month, median_claim, claim_ratio)
# Merge claims data to tract-level panel.
df_model_prep <- df_model_prep %>%
left_join(df_claims_join, by = "year_month")
# Check merge success.
claims_merge_stats <- df_model_prep %>%
summarize(
total_obs = n(),
has_claims = sum(!is.na(median_claim)),
pct_with_claims = has_claims / total_obs * 100
)
cat("CLAIMS DATA MERGE STATISTICS\n")
cat(sprintf("Observations with claims data: %s (%.1f%%)\n",
comma(claims_merge_stats$has_claims),
claims_merge_stats$pct_with_claims))
# Prepare tax data for joining.
df_tax_join <- df_tax %>%
dplyr::select(GEOID, num_props, balance, avg_balance, log_delinquent_balance,
delinquent_prop_count, delinquency_age_years)
# Merge tax delinquency data to tract-level panel.
df_model_prep <- df_model_prep %>%
left_join(df_tax_join, by = "GEOID")
# Check merge success.
tax_merge_stats <- df_model_prep %>%
summarize(
total_obs = n(),
has_tax_data = sum(!is.na(avg_balance)),
pct_with_tax = has_tax_data / total_obs * 100
)
cat("TAX DATA MERGE STATISTICS\n")
cat(sprintf("Observations with tax data: %s (%.1f%%)\n",
comma(tax_merge_stats$has_tax_data),
tax_merge_stats$pct_with_tax))
# Retrieve ACS 5-year estimates for Philadelphia County tracts.
# Using 2023 ACS 5-year estimates.
# Define ACS variables to retrieve.
acs_vars <- c(
# Housing characteristics.
"B25003_001",  # total occupied housing units
"B25003_003",  # renter-occupied units
"B25064_001",  # median gross rent
"B25071_001",  # median gross rent as % of income
"B25077_001",  # median home value
# Income and poverty.
"B19013_001",  # median household income
"B17001_001",  # total population for poverty status
"B17001_002",  # population below poverty level
# Employment.
"B23025_001",  # total population 16+ in labor force
"B23025_005",  # unemployed population
# Education.
"B15003_001",  # total population 25+ for education
"B15003_017",  # high school diploma
"B15003_022",  # bachelor's degree
"B15003_023",  # master's degree
"B15003_025",  # doctorate degree
# Demographics.
"B01003_001",  # total population
"B01002_001",  # median age
# Household composition.
"B11001_001",  # total households
"B11001_006",  # female householder no spouse with children
# Housing cost burden.
"B25070_001",  # total renter households for rent burden
"B25070_007",  # renters paying 30-34.9% income on rent
"B25070_008",  # renters paying 35-39.9% income on rent
"B25070_009",  # renters paying 40-49.9% income on rent
"B25070_010"   # renters paying 50%+ income on rent
)
# Retrieve ACS data for Philadelphia County.
acs_data <- get_acs(
geography = "tract",
variables = acs_vars,
state = "PA",
county = "Philadelphia",
year = 2023,
survey = "acs5",
output = "wide",
geometry = FALSE
)
cat("ACS DATA RETRIEVED\n")
cat(sprintf("Tracts with ACS data: %d\n", nrow(acs_data)))
# Engineer meaningful features from raw ACS variables.
df_acs <- acs_data %>%
transmute(
GEOID = GEOID,
# Renter percentage (key eviction vulnerability indicator).
pct_renter = ifelse(B25003_001E > 0, B25003_003E / B25003_001E * 100, NA),
# Median gross rent.
median_rent = B25064_001E,
# Rent burden (rent as % of income).
rent_burden_pct = B25071_001E,
# Median household income (log transform for modeling).
median_income = B19013_001E,
log_median_income = log1p(B19013_001E),
# Poverty rate.
poverty_rate = ifelse(B17001_001E > 0, B17001_002E / B17001_001E * 100, NA),
# Unemployment rate.
unemployment_rate = ifelse(B23025_001E > 0, B23025_005E / B23025_001E * 100, NA),
# Educational attainment (% with bachelor's or higher).
pct_college = ifelse(B15003_001E > 0,
(B15003_022E + B15003_023E + B15003_025E) / B15003_001E * 100, NA),
# Total population.
total_pop = B01003_001E,
log_pop = log1p(B01003_001E),
# Median age.
median_age = B01002_001E,
# Single mother households (% of total households).
pct_single_mother = ifelse(B11001_001E > 0, B11001_006E / B11001_001E * 100, NA),
# Severe rent burden (% of renters paying 35%+ of income on rent).
severe_rent_burden = ifelse(B25070_001E > 0,
(B25070_008E + B25070_009E + B25070_010E) / B25070_001E * 100, NA)
)
# Calculate summary stats for ACS features.
acs_summary <- df_acs %>%
dplyr::select(-GEOID) %>%
pivot_longer(everything(), names_to = "variable", values_to = "value") %>%
group_by(variable) %>%
summarize(
mean = mean(value, na.rm = TRUE),
median = median(value, na.rm = TRUE),
sd = sd(value, na.rm = TRUE),
min = min(value, na.rm = TRUE),
max = max(value, na.rm = TRUE),
pct_missing = sum(is.na(value)) / n() * 100,
.groups = "drop"
)
acs_summary %>%
kable(digits = 2, caption = "ACS Feature Summary Stats") %>%
kable_styling(bootstrap_options = c("striped", "hover"))
# Merge ACS data into model preparation dataset.
df_model_prep <- df_model_prep %>%
left_join(df_acs, by = "GEOID")
# Check merge.
acs_merge_stats <- df_model_prep %>%
summarize(
total_obs = n(),
has_acs = sum(!is.na(pct_renter)),
pct_with_acs = has_acs / total_obs * 100
)
cat("ACS DATA MERGE STATISTICS\n")
cat(sprintf("Observations with ACS data: %s (%.1f%%)\n",
comma(acs_merge_stats$has_acs),
acs_merge_stats$pct_with_acs))
# Filter spatial data to only tracts present in eviction data.
tracts_in_data <- unique(df_model_prep$GEOID)
philly_model_sf <- philly_tracts_sf %>%
filter(GEOID %in% tracts_in_data)
# Create spatial neighbors using Queen contiguity.
neighbors_queen <- poly2nb(philly_model_sf, queen = TRUE)
# Convert to spatial weights matrix.
weights_matrix <- nb2listw(neighbors_queen, style = "W", zero.policy = TRUE)
cat("SPATIAL WEIGHTS MATRIX CREATED\n")
cat(sprintf("Number of tracts in spatial analysis: %d\n", length(neighbors_queen)))
cat(sprintf("Average number of neighbors per tract: %.1f\n",
mean(card(neighbors_queen))))
# Calculate lagged spatial lag of filings for each month.
# Use neighbors' filings from month t-1 (previous month).
# Using same-month neighbor data would be data leakage since we wouldn't have that info at prediction time.
# Create function to calculate spatial lag for a given month using previous month's data.
calculate_lagged_spatial_lag <- function(data, sf_data, weights, target_date) {
# Get previous month's date.
prev_month_date <- target_date %m-% months(1)
# Filter data to previous month.
prev_month_data <- data %>%
filter(date == prev_month_date) %>%
dplyr::select(GEOID, filings_count)
# If no previous month data exists, return NA.
if (nrow(prev_month_data) == 0) {
result <- sf_data %>%
st_drop_geometry() %>%
dplyr::select(GEOID) %>%
mutate(
date = target_date,
spatial_lag_filings = NA_real_
)
return(result)
}
# Match order to spatial data.
sf_matched <- sf_data %>%
left_join(prev_month_data, by = "GEOID") %>%
mutate(filings_count = ifelse(is.na(filings_count), 0, filings_count))
# Calculate spatial lag for weighted average of neighbors' previous month filings.
spatial_lag <- lag.listw(weights, sf_matched$filings_count, zero.policy = TRUE)
# Return as dataframe with the target date, not lag date.
result <- sf_data %>%
st_drop_geometry() %>%
dplyr::select(GEOID) %>%
mutate(
date = target_date,
spatial_lag_filings = spatial_lag
)
return(result)
}
# Get unique dates in data.
unique_dates <- sort(unique(df_model_prep$date))
# Calculate lagged spatial lag for each month.
spatial_lag_df <- map_dfr(unique_dates, function(d) {
calculate_lagged_spatial_lag(df_model_prep, philly_model_sf, weights_matrix, d)
})
# Merge spatial lag back to main data.
df_model_prep <- df_model_prep %>%
left_join(spatial_lag_df, by = c("GEOID", "date"))
cat(sprintf("Observations with spatial lag: %s\n",
comma(sum(!is.na(df_model_prep$spatial_lag_filings)))))
cat(sprintf("First month has NA spatial lag because of no prior month data: %s observations\n",
comma(sum(is.na(df_model_prep$spatial_lag_filings)))))
#| fig-dpi: 300
#| fig-height: 12
#| fig-width: 12
df_model_prep <- df_model_prep %>%
mutate(log_delinquent_prop = log1p(df_model_prep$delinquent_prop_count))
# Custom colors.
custom_colors_diverging <- colorRampPalette(c("#0a8ac5", "#fffefe", "#f03e37"))(200)
# Select numeric features for correlation analysis.
correlation_vars <- df_model_prep %>%
dplyr::select(
# Target and temporal features.
filings_count, filings_lag1, filings_lag2, filings_ma3,
spatial_lag_filings,
# Tax delinquency.
log_delinquent_balance, delinquent_prop_count, log_delinquent_prop,
# ACS socioeconomic indicators.
pct_renter, poverty_rate, severe_rent_burden, unemployment_rate,
log_median_income, pct_single_mother,
# Policy.
moratorium_active
) %>%
filter(complete.cases(.))
# Calculate correlation matrix.
cor_matrix <- cor(correlation_vars)
# Create correlation plot.
corrplot(cor_matrix,
method = "color",
type = "upper",
order = "hclust",
col = custom_colors_diverging,
tl.col = "black",
tl.srt = 45,
addCoef.col = "black",
number.cex = 0.7,
title = "Feature Correlation Matrix",
mar = c(0, 0, 2, 0))
# Define temporal cutoff for train/test split.
train_end_date <- as.Date("2023-12-31")
test_start_date <- as.Date("2024-01-01")
# CORRECTED: Filter for ALL variables needed by the most complex model
df_train <- df_model_prep %>%
filter(
date <= train_end_date,
!is.na(filings_ma3),           # All models use this
!is.na(spatial_lag_filings),   # Models 2-4 use this
!is.na(delinquent_prop_count), # Models 2-4 use this
!is.na(pct_renter),            # Models 3-4 use this
!is.na(poverty_rate),          # Models 3-4 use this
!is.na(severe_rent_burden),    # Models 3-4 use this
!is.na(pct_single_mother),     # Models 3-4 use this
!is.na(racial_majority),       # Models 3-4 use this
!is.na(moratorium_active)      # All models use this
)
df_test <- df_model_prep %>%
filter(
date >= test_start_date,
!is.na(filings_ma3),
!is.na(spatial_lag_filings),
!is.na(delinquent_prop_count),
!is.na(pct_renter),
!is.na(poverty_rate),
!is.na(severe_rent_burden),
!is.na(pct_single_mother),
!is.na(racial_majority),
!is.na(moratorium_active)
)
# Display split statistics.
cat("TRAIN/TEST SPLIT SUMMARY\n")
cat(sprintf("Training Period: %s to %s\n", min(df_train$date), max(df_train$date)))
cat(sprintf("Training Observations: %s\n", comma(nrow(df_train))))
cat(sprintf("Training Months: %d\n", n_distinct(df_train$date)))
cat(sprintf("Test Period: %s to %s\n", min(df_test$date), max(df_test$date)))
cat(sprintf("Test Observations: %s\n", comma(nrow(df_test))))
cat(sprintf("Test Months: %d\n", n_distinct(df_test$date)))
# Compare filing distributions between train and test sets.
train_test_comparison <- bind_rows(
df_train %>% mutate(set = "training"),
df_test %>% mutate(set = "test")
) %>%
group_by(set) %>%
summarize(
n_obs = n(),
mean_filings = mean(filings_count, na.rm = TRUE),
median_filings = median(filings_count, na.rm = TRUE),
sd_filings = sd(filings_count, na.rm = TRUE),
zero_pct = sum(filings_count == 0) / n() * 100,
.groups = "drop"
)
train_test_comparison %>%
kable(digits = 2, caption = "Filing Distribution Comparison: Training vs Test Sets") %>%
kable_styling(bootstrap_options = c("striped", "hover"))
# Fit baseline Negative Binomial model with core time, policy, and monthly predictors.
model_nb_1 <- glm.nb(filings_count ~ filings_ma3 + moratorium_active + factor(month_num),
data = df_train)
# Display 1st model summary.
cat("BASELINE NEGATIVE BINOMIAL MODEL SUMMARY\n")
summary(model_nb_1)
model_nb_2 <- glm.nb(filings_count ~
filings_ma3 + moratorium_active + factor(month_num) +
# Added spatial lag and delinquent properties because they're more actionable.
spatial_lag_filings + delinquent_prop_count,
data = df_train)
# Display 2nd model summary.
cat("2ND NEGATIVE BINOMIAL MODEL SUMMARY\n")
summary(model_nb_2)
model_nb_3 <- glm.nb(filings_count ~
# 1st model.
filings_ma3 + moratorium_active + factor(month_num) +
# 2nd model.
spatial_lag_filings + delinquent_prop_count +
# Add demographics.
pct_renter + severe_rent_burden + poverty_rate + pct_single_mother +
factor(racial_majority),
data = df_train)
# Display 3rd model summary.
cat("3RD NEGATIVE BINOMIAL MODEL SUMMARY\n")
summary(model_nb_3)
model_nb_4 <- glm.nb(filings_count ~
# 1st model.
filings_ma3 + moratorium_active + factor(month_num) +
# 2nd model.
spatial_lag_filings + delinquent_prop_count +
# 3rd model.
pct_renter + severe_rent_burden + poverty_rate + pct_single_mother +
factor(racial_majority) +
# Add interactions.
factor(racial_majority):moratorium_active,
data = df_train)
cat("FULL NEGATIVE BINOMIAL MODEL SUMMARY\n")
summary(model_nb_4)
# Compare model fit statistics.
model_comparison <- data.frame(
model = c("Baseline", "+ Tax and Spatial", "+ ACS", "+ Interactions"),
aic = c(AIC(model_nb_1), AIC(model_nb_2), AIC(model_nb_3), AIC(model_nb_4)),
theta = c(model_nb_1$theta, model_nb_2$theta, model_nb_3$theta, model_nb_4$theta),
loglik = c(logLik(model_nb_1), logLik(model_nb_2), logLik(model_nb_3), logLik(model_nb_4))
) %>%
mutate(
delta_aic = aic - min(aic),
rank = rank(aic)
)
model_comparison %>%
kable(digits = 2, caption = "Model Comparison Statistics (Lower AIC = Better Fit)") %>%
kable_styling(bootstrap_options = c("striped", "hover")) %>%
row_spec(which.min(model_comparison$aic), bold = TRUE, background = "#E8F6F3")
# Check VIF for final model (Model 4)
vif_check <- lm(filings_count ~ filings_ma3 + moratorium_active +
spatial_lag_filings + delinquent_prop_count +
pct_renter + severe_rent_burden + poverty_rate + pct_single_mother +
factor(racial_majority),
data = df_train) %>% vif()
vif_results <- data.frame(Variable = names(vif_check), VIF = vif_check) %>%
arrange(desc(VIF))
